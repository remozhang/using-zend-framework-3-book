# Zend Skeleton Application {#skeleton}

# Zend 框架应用程序

Zend Framework 3 provides you with the so called "skeleton application" to make it easier to create 
your new websites from scratch. In this chapter, we will show how to install the skeleton 
application and how to create an Apache virtual host. It is recommended that you refer to 
[Appendix A. Configuring Web Development Environment](#devenv) before reading this chapter to get your development 
environment configured.

Zend Framework3 提供称为 "skeleton application" 使得更为简单地去从头创建应用. 在这个章节, 我们会展示给你
如何创建一个 Apache 虚拟主机. 推荐你在阅读本章节去获取环境配置前去参考[附录 A. 配置网络开发环境](#devenv).

## Getting Zend Skeleton Application

## 获取 Zend 框架应用

The Skeleton Application is a simple ZF3-based application that contains 
most necessary things for creating your own website.

这个框架应用是简化的基于 ZF3 的应用. 包含绝大多数创建你自己站点时所必要的东西.

The skeleton application's code is stored on GitHub code hosting and can be publicly 
accessed by [this link](https://github.com/zendframework/ZendSkeletonApplication).
However, you typically do not download the source code of the skeleton application directly, 
instead you use [Composer](http://getcomposer.org/) dependency manager, as shown below.

这个框架应用的代码被存储在 GitHub 代码主机上, 能被公开访问通过
[这个链接](https://github.com/zendframework/ZendSkeletonApplication).
然而, 你通常不会下载直接下载这个框架应用的源代码, 取而代之, 你可以使用 [Composer](http://getcomposer.org/)
依赖管理, 见下文.

First, you need to get the latest version of Composer. You do this with the following commands:

首先, 你需要去获取最新的 composer, 你可以通过下面的命令:

```
cd ~

php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"

php composer-setup.php

php -r "unlink('composer-setup.php');"
```

The commands above change your working directory to be your home directory, download the `composer-setup.php` installer script 
to your working directory, run it, and, finally, remove the installer.

这个上述命令行将你的工作目录指向为你的 home 目录, 下载 `composer-setup.php` 安装器脚本到
你的工作目录, 运行这个脚本, 最后, 移除, 这个安装器脚本.

T> Once you run the commands above, you should have the `composer.phar` file in your working directory.
T> 一旦你运行了上述的命令, 你会有一个 `composer.phar` 文件到你的当前工作目录.

Now, type the following command from your command prompt:

现在, 从你的命令行提示框键入随后的命令:

```
php composer.phar create-project -sdev zendframework/skeleton-application helloworld
```

The command above downloads the Zend Skeleton Application to `helloworld` directory and runs its 
interactive installer. You now should answer several yes/no questions by typing `y` or `n` and pressing Enter.
Your answers will help the installer to determine which dependencies to install.
If you don't know what to answer, answer 'n' (no); you will be able to install additional dependencies
later at any time.

这个上述的命令下载 Zend 框架应用到 `helloworld` 目录以及运行了它的交互安装器.
你现在应该回答几个是/否的问题通过键入 `y` 和 `n` 和按回车,
你的回复可以帮助安装器去确认哪个依赖需要去安装. 如果你不知道怎么回答, 就回答 'n' (否);
你可以安装附加依赖在任意晚点的时间.

For the beginning, you can answer the questions the following way:

一开始, 你可以回答问题跟随以下方式:

```
    Do you want a minimal install (no optional packages)? Y/n
n

    Would you like to install the developer toolbar? y/N
n

    Would you like to install caching support? y/N
n

    Would you like to install database support (installs zend-db)? y/N
n

    Would you like to install forms support? y/N
y
    Will install zendframework/zend-mvc-form (^1.0)
    When prompted to install as a module, select application.config.php or modules.config.php

    Would you like to install JSON de/serialization support? y/N
n

    Would you like to install logging support? y/N
n

    Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N
n

    Would you like to install i18n support? y/N
n

    Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N
n

    Would you like to use the PSR-7 middleware dispatcher? y/N
n

    Would you like to install sessions support? y/N
n

    Would you like to install MVC testing support? y/N
n

    Would you like to install the zend-di integration for zend-servicemanager? y/N
n
```

Once you answer the questions, the installer will download and install all necessary packages and asks
you to which config file you would like to inject information about installed modules. When prompted,
type '1' and press Enter:

一旦你回答了问题, 这个安装器就会下载安装全部必要的包以及询问关于安装模块的信息, 你想要注入哪个配置文件,
当提示框键入 '1' , 按下回车:

```
 Please select which config file you wish to inject 'Zend\Form' into:
  [0] Do not inject
  [1] config/modules.config.php
  [2] config/development.config.php.dist
  Make your selection (default is 0):1

  Remember this option for other packages of the same type? (y/N) y
```

Next, the installer will ask you if you would like to remove existing version control files from the project.
Since you will probably store your web application in your own version control system (like Git) and do not need
existing VCS files, type 'y' and press Enter:

接着, 这个安装器会问你是否愿意从项目中移除已经存在的版本控制文件. 由于你可能会将你的网络应用存储在你
自己的版本控制系统中(像 Git), 所以不需要已经存在的 VCS 文件, 键入 'y', 按下回车:

```
Do you want to remove the existing VCS (.git, .svn..) history? [Y,n]? y
```

Now copy `composer.phar` file to your new `helloworld` directory:
现在, 将 `composer.phar` 文件拷贝到你新的 `helloworld` 目录下:

```
cp composer.phar helloworld
```

And final and very important step is enabling the *development mode* by typing the following command:

接着最后非常重要的异步就是启动 *development mode*, 通过键入以下命令开启:

~~~
cd helloworld
php composer.phar development-enable
~~~ 

I> The development mode is typically used when you *develop* your application. When you enable the development
I> mode additional "development" configuration files are created in your web application's `config` directory. In this 
I> mode your application may optionally load additional "development" modules. Configuration caching
I> is also disabled in this mode allowing you to change your website's configuration files and see the changes immediately.
I>
I> Once you have finished the development, you can enable the *production* mode by typing the following:
I> 
I> `php composer.phar development-disable`

I> 这个开发模式是当你 *develop* 你的应用时被使用得非常典型. 当你开启这个开发模式
I> 附带的 "development" 配置文件被创建到你的网络应用的 `config` 目录当中. 在这个模式下
I> 你的应用可能会随意读取附带的 "development" 模块. 在这种模式下, 配置缓存也是不可用的,
I> 允许你去改变你的网站配置文件以及马上看到改变.
I>
I> 一旦你完成了开发, 你可以开启 *production* 模式通过键入以下:
I> `php composer.phar development-disable`

Congratulations! The hard work is done. Now let's look inside the `helloworld` directory.

恭喜你! 最困难的工作已经完成. 现在让我们往 `helloworld` 目录里面看.

## Typical Directory Structure
## 典型的目录结构

Every ZF3-based website (including the skeleton application) is organized in the same recommended way. 
Of course, you can configure your application to use a different directory layout, but this may 
make it difficult to support your website by other people who are not familiar
with such a directory structure.

每一个基于 ZF3 的网络站点 (包括框架引用) 都是用同样推荐的方法被组织起来.
当然, 你能使用不同的目录层去配置你的应用, 但是这样使得其他人可能跟你的目录结构不同导致接手你的站点变得更为困难.

Let's have a brief look at the typical directory structure (see figure 2.1):
让我们简短地看一下典型的目录结构(见 图 2.1):

![Figure 2.1. Typical Directory Structure](images/skeleton/skeleton_dir_structure.png)
![图 2.1. 典型的目录结构](images/skeleton/skeleton_dir_structure.png)

As you can see, in the top-level directory (we will denote it `APP_DIR` from now on),
there are several files:
正如你所看到的, 在这最上层的目录(从现在开始, 我们把它命名为 `APP_DIR`),
那里有几个文件:

* `composer.json` is a JSON configuration file for Composer.
* `composer.json` 是 Composer 的一个 JSON 格式的配置文件.

* `composer.lock` file contains information about packages installed with Composer.
* `composer.lock` 文件包含关于 Composer 已经安装的包的信息.

* `composer.phar` is an executable PHP archive containing the code 
  of Composer dependency management tool.
* `composer.phar` 是一个 可执行的 PHP 归档, 它包含 Composer 依赖管理工具的代码.

* `docker-compose.yml` and `Dockerfile` files are auxiliary files used only if you use [Docker](https://www.docker.com) container manager tool. 
  In this book, we do not cover usage of Docker.
* `docker-composer.yml` 和 `Dockerfile` 文件是辅助文件, 仅仅当你使用 [Docker](https://www.docker.com) 容器管理工具时被用到.
  在这本书中, 我们不会涵盖 Docker 的使用方法.

* `LICENSE.md` is a text file containing ZF3 license (you had a chance to read it in 
 [Introduction to Zend Framework 3](#intro)).
  Do not remove or modify this file, because ZF3 license doesn't allow to do so.
* `LICENSE.md` 是一个文本文件, 它包含 ZF3 许可证(你有机会阅读到他在
  [Zend Framework 3 概述](#intro)).
  不要移除或者修改这个文件, 因为 ZF3 许可证不允许这样做.

* `phpunit.xml.dist` file is a configuration for [PHPUnit](https://phpunit.de/) (unit testing framework). You use this file
  when you want to create unit tests for your website.
* `phpunit.xml.dist` 文件是一个属于 [PHPUnit](https://phpunit.de/) (单元测试框架)的配置文件. 当你想为你的站点创建单元测试的时候使用他
  
* `README.md` is a text file containing a brief description of the skeleton application. You typically
  will replace this file contents with the information about your website: its name, what it does,
  and how to install it.
* `README.md` 是一个包含一个框架应用简短描述的文本文件. 你一般会用你的站点信息替换掉它, 它的名字, 它用来干啥, 以及怎样去安装他.
   
* `TODO.md` is an auxiliary file that can be safely removed.
* `TODO.md` 是一个辅助文件, 可以被安全地移除.
  
* `Vagrantfile` is an auxiliary file that contains configuration for [Vagrant](https://www.vagrantup.com/), which is a virtual development
  environment manager. You can ignore this file if you don't know what is Vagrant. In this book, we do not use Vagrant.
* `Vagrantfile` 是一个辅助文件, 包含属于 [Vagrant](https://www.vagrantup.com/) 的配置信息, Vagrant 是一个虚拟开发环境管理器.
  你能忽略掉这个文件如果你不知道什么是 Vagrant . 在这本书中, 我们不使用 Vagrant.

And we also have several subdirectories:

以及我们同样有几个子目录:

The `config` directory contains application-level configuration files.

`config` 目录包含应用级的配置文件

The `data` directory contains the data your application might create; it may also contain cache used to speed-up Zend Framework.

`data` 目录包含你的应用可能创建的数据; 它也包含缓存, 为了去加快 Zend Framework 的速度.

The `module` directory contains all application modules. Currently there is a 
single module called `Application`. The `Application` is the main module of your 
website. You can also put other modules here, if you wish. We will talk about
the modules a little bit later.

`module` 目录包含了所有应用模块. 目前有一个单一的名叫 `Application`的模块. `Application` 是你的站点的主要模块
你也能将其他模块放在这里, 如果你期待, 我们会在后续中更为深入地讨论这个模块.

The `vendor` directory's purpose is to contain third-party library files, including 
Zend Framework 3 library files. This directory is typically populated by Composer.

`vendor` 目录的目的是包含第三方库文件, 包括 Zend Framework 3 库文件. 这个目录一般被 Composer 填充.

The `public` directory contains data publicly accessible by the web-user. As you can see, web-users
will mainly communicate with the `index.php`, which is also called the *entry point* of your website.

`public` 目录包含的数据对于网络用户可以公开访问. 你可以看到, 用户主要与 `index.php` 交流. 也被称为是你的站点的入口点.

I>Your website will have a single entry point, *index.php*, because this is more secure than allowing
I>anyone to access all your PHP files.

I> 你的站点将会有一个单一的入口点, *index.php*, 因为这会比允许任何人访问你所有 PHP 文件更为安全.

Inside of the `public` directory, you can also find hidden `.htaccess` file. Its main purpose is to define 
URL rewriting rules.

作为 `public` 目录的替代, 你可以找到隐藏的 `.htaccess` file. 它的主要目标是定义 URL 重写规则.

The `public` directory contains several subdirectories also publicly accessible by web-users:

`public` 目录包含几个子文件夹也能被用户公开访问到:

* `css` subdirectory contains all publicly accessible CSS files;
* `fonts` subdirectory contains application-specific web-fonts;
* `img` subdirectory contains publicly accessible images (*.JPG, *.PNG, *.GIF, *.ICO, etc.);
* and `js` subdirectory stores publicly accessible JavaScript files used by your web-pages. 
  Typically, files of [jQuery](http://jquery.com/) library are placed here, but you can put your own JavaScript files here, too.

* `css` 子文件夹包含所有公开访问的 CSS files;
* `fonts` 子文件夹包含应用中特定的网络字体;
* `img` 子文件夹包含公开访问的图片(*.JPG, *.PNG)
* 以及 `js` 子文件夹存储你的网站页面中公开的 JavaScript 文件, 一般而言, [jQuery](http://jquery.com/) 库会替换到这里, 但你能将
  你的 JavaScript 文件放在这里

Q> **What is jQuery library?**
Q> 
Q> jQuery is a JavaScript library which was created to simplify the client-side scripting of HTML
Q> pages. jQuery's selector mechanism allows to easily attach event handlers to certain HTML elements, making
Q> it really simple to make your HTML pages interactive.
  
Because the Zend Skeleton Application is stored on GitHub, inside of the directory structure, 
you can find hidden `.gitignore` file. This is a [GIT](http://git-scm.com/) version control 
system's files. You can ignore it (or even remove them if you do not plan to store your code in a GIT repository).

因为 Zend 框架被存放在 GitHub, 在目录框架里面, 你能找到隐藏的 `.gitignore` 文件. 它是一个 [GIT](http://git-scm.com/)
版本控制系统文件, 你能忽略掉它(你不打算在一个 GIT 仓库中存储你的代码甚至或者呢可以移除掉它).

## Application Dependencies
## 应用依赖

A dependence is some third-party code your app uses. For example Zend Framework 3 is the dependence for your website. 
一个依赖就是你的应用使用的一些第三方代码.举个例子, Zend Framework 3 就是你的站点的依赖.

In Composer, any library is called *a package*. All packages installable by Composer
are registered on [Packagist.org](https://packagist.org/) site. 
With Composer, you can identify the packages that your app requires and have Composer to download and install them automatically.

在 Composer 中, 任何一个库都被称为 *a package*. 所有可以安装的包都被 Composer 注册在 [Packagist.org](https://packagist.org/) 站点.
有了 Composer, 你可以确定你应用需要的包, 以及用 Composer 去下载和自动安装它们.

The dependencies of the skeleton application are declared in `APP_DIR/composer.json` file (see below):
框架依赖在 `APP_DIR/composer.json` 文件中被声明到. (见下文):

{line-numbers=off,lang=text, title="Contents of composer.json file"}
~~~
{
    "name": "zendframework/skeleton-application",
    "description": "Skeleton Application for Zend Framework zend-mvc applications",
    "type": "project",
    "license": "BSD-3-Clause",
    "keywords": [
        "framework",
        "mvc",
        "zf2"
    ],
    "homepage": "http://framework.zend.com/",
    "minimum-stability": "dev",
    "prefer-stable": true,
    "require": {
        "php": "^5.6 || ^7.0",
        "zendframework/zend-component-installer": "^1.0 || ^0.3 || ^1.0.0-dev@dev",
        "zendframework/zend-mvc": "^3.0.1",
        "zfcampus/zf-development-mode": "^3.0",
        "zendframework/zend-mvc-form": "^1.0",
        "zendframework/zend-mvc-plugins": "^1.0.1",
        "zendframework/zend-session": "^2.7.1"
    },
    "autoload": {
        "psr-4": {
            "Application\\": "module/Application/src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "ApplicationTest\\": "module/Application/test/"
        }
    },
    "extra": [],
    "scripts": {
        "development-disable": "zf-development-mode disable",
        "development-enable": "zf-development-mode enable",
        "development-status": "zf-development-mode status",
        "serve": "php -S 0.0.0.0:8080 -t public/ public/index.php"
    }
}
~~~

Q> **What is JSON?**
Q>
Q>JSON (JavaScript Object Notation), is a text-based file format used for human-readable 
Q>representation of simple structures and nested associative arrays. Although JSON 
Q>originates from JavaScript, it is used in PHP and in other languages, because
Q>it is convenient for storing configuration data.

In that file, we see some basic info on the skeleton application (its name,
description, license, keywords and home page). You will typically change this info for your future
websites. This information is optional, so you can even safely remove it,
if you do not plan to publish your web application on `Packagist` catalog.
在这个文件中, 我们看到一些框架应用上的信息(它的名字, 描述, 许可证, 关键词, 以及主页).
你一般可以为了你的未来站点改变这些信息. 这个信息是可以选择的, 所以你甚至可以安全地移除他,
如果你不打算在 `Packagist` 目录防止你的网络应用的话.

What is interesting for us now is the `require` key. The `require`
key contains the dependencies declarations for our application. We see that we
require PHP engine version 5.6 or later and several Zend Framework components, like `zend-mvc`, `zend-mvc-form`, etc.
现在我们感兴趣的是 `require` 关键词. 这个 `require` 关键词包含我们的应用的依赖声明. 我们可以看到, 我们需要 PHP 引擎版本 5.6 或者
以上, 以及几个 Zend Framework 组件, 像 `zend-mvc`, `zend-mvc-form`, 等等.

The information contained in `composer.json` file is enough to locate the
dependencies, download and install them into the `vendor` subdirectory. If at any time you determine
that you need to install another dependency, you can do that by editing `composer.json` and adding your dependency in it, 
and then typing the following commands from your command shell:
包含在 `composer.json` 文件中的信息是足够去定位这些依赖, 下载和安装它们到 `vendor` 子文件夹.
如果在任何时间你确定需要安装另一个依赖, 你能通过编辑 `composer.json`, 加入你的依赖到里面, 然后兼容以下命令到你的命令行:


{line-numbers=off}
~~~
php composer.phar self-update
php composer.phar install
~~~

The commands above will self-update the Composer to the latest available version, and then
install your dependencies. By the way, Composer does not install PHP for you,
it just ensures PHP has an appropriate version, and if not, it will warn you. 
上述的命令会自己更新 Composer 到最新可用版本, 然后安装你的依赖. 顺带一提, Composer 不会为你安装 PHP,
它仅仅确保 PHP 有一个合适的版本, 如果不是的话, 它警告你.


If you look inside the `vendor` subdirectory, you can see that it contains a lot of files.
Zend Framework 3 files can be found inside the `APP_DIR/vendor/zendframework/`
directory (figure 2.2).
如果你往 `vendor` 子文件夹里面看, 你可以看到它包含很多文件.
Zend Framework 3 文件能在 `APP_DIR/vendor/zendframework/` 目录下被找到 (图 2.2)

![Figure 2.2. Vendor directory](images/skeleton/vendor_dir.png)
![图 2.2. Vendor 目录](images/skeleton/vendor_dir.png)


I> In some other frameworks, another (conventional) way of dependency installation is used.
I> You just download the dependency library as an archive, unpack it and put it somewhere inside of your
I> directory structure (typically, to `vendor` directory). This approach was used in Zend Framework 1.
I> But, in Zend Framework 3, you are recommended to install dependencies with Composer.

I> 在一些其他框架, 使用另一种 (传统) 的依赖安装方法.
I> 你只需要下载依赖库作为一个档案, 打开他, 将他放入你的文件夹结构中(一般来说,  到`vendor` 文件夹). 这种方法与
Zend Framework 1 的用法接近. 但是, 在 Zend Framework 3 中, 推荐你用 Composer 安装依赖.

## Apache Virtual Host
## Apache 虚拟主机

Now we are almost ready to get our skeleton website live! The last thing we 
are going to do is configure an Apache virtual host. A virtual host term means 
that you can run several websites on the same machine. The virtual sites are 
differentiated by domain name (like `site.mydomain.com` and `site2.mydomain.com`) or
by port number (like `localhost` and `localhost:8080`). Virtual hosts work 
transparently for site users, that means users have no idea whether the sites are 
working on the same machine or on different ones.

现在, 我们已经准备好了让我们的框架站点变活! 我们最后需要做的一件事是配置 Apache 虚拟主机.
一个虚拟主机术语意味着你能在同一个机器上跑若干站点. 虚拟站点可以通过域名名称区分 (像 `site.mydomain.com` 和
`site2.mydomain.com`) 以及通过端口数字区分 (像 `localhost` 和 `localhost:8080`).
虚拟主机显而易见是为站点用户工作, 意味着用户不知道站点是运行在同一个机器, 还是不同的.

Currently, we have the skeleton application inside of your home directory. To let Apache know
about it, we need to edit the virtual host file.
现在, 我们在你的 home 目录下有了框架, 为了让 Apache 知道它, 我们需要去编辑虚拟主机文件

I> Virtual host file may be located at a different path, depending on your operating system type. 
I> For example, in Linux Ubuntu it is located in `/etc/apache2/sites-available/000-default.conf` file.
I> For OS- and server-specific information about virtual hosts, please refer to [Appendix A. Configuring Web Development Environment](#devenv).

I> 虚拟主机文件可能被放置在不同的路径, 取决于你的操作系统类型.
I> 举个例子, 在 Linux Ubuntu 它是被防止在 `/etc/apache2/sites-available/000-default.conf` 文件中.
I> 对于OS- 以及几个特定的关于虚拟主机的信息, 请参考[附录 A. 配置网络开发环境](#devenv)

Let's now edit the default virtual host file to make it look like below (we assume you use Apache v2.4):
让我们编辑默认的虚拟主机文件, 让它看上去跟下面一样(我们假定你使用 Apache v2.4):

{line-numbers=on,lang=text, title="Virtual host file"}
~~~
<VirtualHost *:80>
    ServerAdmin webmaster@localhost

    DocumentRoot /home/username/helloworld/public
    
	<Directory /home/username/helloworld/public/>
        DirectoryIndex index.php
        AllowOverride All
        Require all granted
    </Directory>

</VirtualHost>
~~~

Line 1 of the file makes Apache to listen to all (*) IP addresses on port 80.
文件的第一行让 Apache 监听所有 (*) 在端口 80 的 IP 地址

Line 2 defines the web master's E-mail address. If something bad happens to the 
site, Apache sends an alert E-mail to this address. You can enter your E-mail
here.
第二行定义了网站 master 的 E-mail 地址. 如果站点发生了一些糟糕的事情. Apache 发送一个告警邮件到这个地址.
你可以键入你的邮件地址到这里

Line 4 defines the document root directory (`APP_DIR/public`). All files and directories
under the document root will be accessible by web-users. You should set
this to be the absolute path to skeleton application's `public` directory.
So, the directories and files inside `public` (like `index.php`, `css`, `js`, etc.)
will be accessible, while directories and files above `public` directory (like 
`config`, `module`, etc.) wont' be accessible by web users, which enhances the 
security of the website.

第四行定义了文档根目录 (`APP_DIR/public`). 所有在这个根目录下的文件以及目录能被网络用户访问.
你应该用一个指向框架 `public` 的绝对路径来配置它. 所以, 那些在 `public` 下的目录以及文件
(像 `index.php`, `css`, `js` 等等) 都能被访问到. 当目录以及文件在 `public` 目录上层 (像 `config`,
`module` 等等) 不会被访问到. 这样提高了网站的安全性.

Lines 6-10 define rules for the document root directory (`APP_DIR/public`). For example, the `DirectoryIndex` 
directive tells Apache that *index.php* should be used as the default index file. The `AllowOverride All` directive
allows to define any rules in `.htaccess` files. The `Require all granted` directive allows 
everyone to visit the website.

第 6-10 行定义了文档根目录 (`APP_DIR/public`) 的规则. 举个例子, `DirectoryIndex` 指令告知 Apache
*index.php* 应该被作为默认的索引文件所使用. `AllowOverride All` 指令允许在 `htaccess` 中定义任何规则
`Require all granted` 指令允许人和人去访问站点.

W> Zend Framework 3 utilizes Apache's URL rewriting module for redirecting 
W> web-users to entry script of your website. Please ensure that your web server
W> has `mod_rewrite` module enabled. For instructions on how to enable the module, please
W> refer to [Appendix A. Configuring Web Development Environment](#devenv).

W> Zend Framework 3 利用 Apache 的 URL 重写模块来重定向用户进入你站点的脚本. 请确保
W> 你的站点服务 `mod_rewrite` 模块开启. 关于如何开启该模块的介绍, 请参考
W> [附录 A. 配置网络开发环境](#devenv).

T> After editing the config file, do not forget to restart Apache to apply your changes.
T> 当编辑完配置文件, 不要忘了重启 Apache 去应用你做出的改变.

## Opening the Website in Your Browser
## 在你的浏览器中打开网站
To open the website, type "http://localhost" in your browser's navigation bar and press Enter.
Figure 2.3 shows the site in action.

为了打开网站, 键入 "http://localhoyst" 到你的浏览器导航栏, 然后按下空格.
图 2.3 显示站点正在活动

On the page that appears, you can see the navigation menu at the top. The navigation bar currently
contains the single link named *Home*.
Under the navigation bar, you can see the "Welcome to Zend Framework" caption. Below
the caption, you can find some advices for beginners on how to develop new ZF3-based
applications.
当页面出现, 你能看到导航菜单在顶部. 导航栏当前包含单一的名叫 *Home* 的链接.
在导航栏下方, 你能看到 "Welcome to Zend Framework" 标题. 在标题下方, 你能找到一些关于如何开发新
的基于 ZF3 的应用.


![Figure 2.3. Zend Skeleton Application](images/skeleton/zend_skeleton_default_view.png)
![图 2.3. Zend 框架](images/skeleton/zend_skeleton_default_view.png)

## Creating NetBeans Project

Now that we have the skeleton application set up and working, we will want to change something
with it in the future. To easily navigate the directory structure, edit files and debug the 
website, the common practice is to use an IDE (Integrated Development Environment). In this book, we
use NetBeans IDE (see [Appendix A. Configuring Web Development Environment](#devenv) for more information on how to install NetBeans). 

To create NetBeans project for our skeleton application, run NetBeans and open menu 
*File->New Project...*. The *New Project* dialog appears (see figure 2.4).

![Figure 2.4. Creating NetBeans Project - Choose Project Page](images/skeleton/netbeans_create_project.png)

In the *Choose Project* page that appears, you should choose PHP project type 
and in the right list select *Application with Existing Sources*
(because we already have the skeleton application's code). Then click the *Next* button to go to the next page 
(shown in figure 2.5).  

![Figure 2.5. Creating NetBeans Project - Name and Location Page](images/skeleton/netbeans_create_project_step2.png)

In the *Name and Location* dialog page, you should enter the path to the code (like */home/username/helloworld*),
the name for the project (for example, `helloworld`) and specify the version of PHP your code uses (PHP 5.6 or later). 
The PHP version is needed for the NetBeans PHP syntax checker which will scan your PHP code for errors and
highlight them. Press the *Next* button to go to the next dialog page (shown in figure 2.6).

![Figure 2.6. Creating NetBeans Project - Choosing Configuration Page](images/skeleton/netbeans_create_project_step3.png)

In the *Run Configuration* page, it is recommended that you specify the way you run the website (Local Web 
Site) and website URL (`http://localhost`). Keep the *Index File* field empty (because we are using `mod_rewrite`,
the actual path to your `index.php` file is hidden by Apache). If you are seeing the warning message like 
"Index File must be specified in order to run or debug project in command line", just ignore it. 

Click the *Finish* button to create the project. When the *helloworld* project 
has been successfully created, you should see the project window (see the figure 2.7).

![Figure 2.7. NetBeans Project Window](images/skeleton/netbeans_project_window.png)

In the project window, you can see the menu bar, the tool bar, 
the *Projects* pane where your project files are listed, and, in the right
part of the window, you can see the code of the `index.php` entry file.

Please refer to [Appendix B. Introduction to PHP Development in NetBeans IDE](#netbeans) 
for more NetBeans usage tips, including launching and interactively debugging 
ZF3-based websites. 

T> **It's time for some advanced stuff...**
T> 
T> Congratulations! We've done the hard work of installing and running 
T> the Zend Skeleton Application, and now it's time to have a rest 
T> and read about some advanced things in the last part of this chapter.

## Hypertext Access File (.htaccess)

We've mentioned the `APP_DIR/public/.htaccess` file when talking about typical
directory structure. Now let's try to understand the role of this file. 

The `.htaccess` (hypertext access) file is actually an Apache web server's 
configuration file allowing to override some web server's global configuration. 
The `.htaccess` file is a directory-level configuration, which means it 
affects only its owning directory and all sub-directories.

The content of `.htaccess` file is presented below:

{line-numbers=on,lang=text}
~~~
RewriteEngine On
# The following rule tells Apache that if the requested filename
# exists, simply serve it.
RewriteCond %{REQUEST_FILENAME} -s [OR]
RewriteCond %{REQUEST_FILENAME} -l [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^.*$ - [L]
# The following rewrites all other queries to index.php. The 
# condition ensures that if you are using Apache aliases to do
# mass virtual hosting or installed the project in a subdirectory,
# the base path will be prepended to allow proper resolution of
# the index.php file; it will work in non-aliased environments
# as well, providing a safe, one-size fits all solution.
RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\2$
RewriteRule ^(.*) - [E=BASE:%1]
RewriteRule ^(.*)$ %{ENV:BASE}/index.php [L]
~~~

Line 1 tells Apache web server to enable URL rewrite engine (`mod_rewrite`).  The rewrite engine modifies
the incoming URL requests, based on regular expression rules.
This allows you to map arbitrary URLs onto your internal URL structure in any way you like.

Lines 4 - 7 define rewrite rules that tell the web server that if the client (web browser)
requests a file that exists in the document root directory, than to return the contents of that
file as HTTP response. Because we have our `public` directory inside of the virtual host's document root,
we allow site users to see all files inside of the `public` directory, including `index.php`, 
CSS files, JavaScript files and image files.

Lines 14 - 16 define rewrite rules that tell Apache what to do if the site user requests a file
which does not exist in document root. In such a case, the user should be redirected to `index.php`.

Table 2.1 contains several URL rewrite examples. The first and second URLs point to existing
files, so `mod_rewrite` returns the requested file paths. The URL in the third example 
points to a non-existent file `htpasswd` (which may be a symptom of a hacker attack), 
and based on our rewrite rules, the engine returns `index.php` file.

{title="Table 2.1. URL rewrite examples"}
|-------------------------------------|-----------------------------------------|
| **Requested URL**                   | **Rewritten URL**                       |
|-------------------------------------|-----------------------------------------|
| `http://localhost/index.php`        | File exists; return the local file      |
|                                     | `APP_DIR/public/index.php`              |
|-------------------------------------|-----------------------------------------|
| `http://localhost/css/bootstrap.css`| File exists; return the local file      | 
|                                     | `APP_DIR/public/css/bootstrap.css`      |
|-------------------------------------|-----------------------------------------|
| `http://localhost/htpasswd`         | File does not exist; return             |
|                                     | `APP_DIR/public/index.php` instead.     |
|-------------------------------------|-----------------------------------------|

## Blocking Access to the Website by IP Address
## 通过 IP 地址屏蔽站点访问

Sometimes it may be required to block access to your website from all other IP addresses except yours.
For example, when you develop a website, you don't want someone to see your incomplete work. Also,
you may not want to let Google or other search engines to index your website.
有时候, 需要从其他 IP 地址屏蔽掉你的站点.
举个例子, 当你开发一个站点, 你不希望某个人看到你没有完成的工作.
当然, 你也不太可能希望 Google 或者其他搜索引擎索引你的站点.
To forbid access to your site, you can modify the virtual host and add the following line to it:
为了禁止访问你的站点, 你能修改虚拟主机, 在里面添加以下代码:
{line-numbers=off,lang=text}
~~~
Require ip <your_ip_address>
~~~

Q> **How do I determine my IP address?**
Q>
Q> You can use the [http://www.whatismyip.com](http://www.whatismyip.com/) website to determine 
Q> your external IP address. The external IP address is the address by which other 
Q> computers on the Internet may access your site.

Q> **我如何确认我的 IP 地址?**
Q>
Q> 你能通过使用 [http://www.whatismyip.com](http://www.whatismyip.com/) 去确认你外部的 IP 地址.
Q> 外部的 IP 地址是其他在互联网上的电脑可能访问到你的站点的地址.

## HTTP Authentication

You may want to allow access to your site to certain users. For example, when you are 
demonstrating your website to your boss, you will give her username and password for
logging into your site.

To allow access to your website by username and password, you can modify the virtual host 
file as follows:

{line-numbers=on,lang=text}
~~~
...
<Directory /home/username/helloworld/public/>
    DirectoryIndex index.php
    AllowOverride All
    AuthType Basic
    AuthName "Authentication Required"
    AuthUserFile /usr/local/apache/passwd/passwords
    Require valid-user
</Directory>
...
~~~

Line 5 defines Basic authentication method. The most common method is 
Basic. It is important to 
be aware, however, that Basic authentication sends the password from the client 
to the server unencrypted. This method should therefore not be used for highly 
sensitive data. Apache supports one other authentication 
method: `AuthType Digest`. This method is much more 
secure. Most recent browsers support Digest authentication.

Line 6 defines the text that will be displayed to user when he tries to log in.

Line 7 defines the file where passwords will be stored. This file should be created
with the `htpasswd` utility.

Line 8  will allow anyone to log in that is listed in the password file, 
and who correctly enters their password.

To create `passwords` file, type the following command:

~~~
htpasswd -c /usr/local/apache/passwd/passwords <username>
~~~

In the command above, you should replace the `<username>` placeholder 
with the name of the user. You can choose an arbitrary name, for example "admin".
The command will request the user's password and write the password to the file:

{line-numbers=off,lang=text}
~~~
# htpasswd -c /usr/local/apache/passwd/passwords <username>
New password: 
Re-type new password: 
Adding password for user <username>
~~~

When the user tries to visit the site, he/she sees the HTTP authentication dialog.
To log into your site, the visitor should enter the correct username and password.  

I> For additional information on HTTP authentication, you can refer to 
I> [Authentication and Authorization](http://httpd.apache.org/docs/current/howto/auth.html)
I> topic of Apache documentation.

## Having Multiple Virtual Hosts

When developing several websites on the same machine, you will want to create
several virtual hosts. For each virtual host you need to specify a domain name (like `site1.mydomain.com`).
But if you currently don't have a domain name, you can specify a different port instead 
(see the example below).

{line-numbers=off,lang=text}
~~~
# Listen directive tells Apache to listen requests on port 8080
Listen 8080

<VirtualHost *:8080>
    ...
</VirtualHost>
~~~

To access the website, in your browser's navigation bar, enter "http://localhost:8080".

T> After editing the virtual host config file, you should restart Apache to apply changes.

## Hosts File

When you have multiple local websites mapped to different ports, it becomes difficult
to remember on which port each site presents. To simplify this, you can use name-based
virtual host and define an alias for your website in your system `hosts` file. 

First, modify your Apache virtual host file to be *name-based* virtual host:

{line-numbers=off,lang=text}
~~~
<VirtualHost *:80>
    # Add the ServerName directive
	ServerName site1.localhost	
	...	
</VirtualHost>
~~~

Next, you should edit the `hosts` file. The `hosts` file is a system file
which contains mappings between IP addresses and host names. The hosts file contains 
lines of text consisting of an IP address in the first text field followed by one or 
more host names.

To add an alias for your local websites, add lines for each of your website as 
shown in the example below. 

{line-numbers=off,lang=text}
~~~
127.0.0.1            site1.localhost
~~~

So now you'll be able to simply enter "site1.localhost" in your browser's address bar
instead of remembering the port number.

I> In Linux, the hosts file is located in `/etc/hosts`.
I> In Windows, the file is typically located in `C:\Windows\System32\drivers\etc\hosts`.
I> To edit the file, you need to be an administrator. Please also note that some
I> anti-virus software may block changes to hosts file, so you'll have to temporarily disable
I> your anti-virus to edit the file, and enable it after.

I> If you have purchased a real domain name for your website (like `example.com`), you do not
I> need to modify your `hosts` file, because Apache will be able to resolve the IP address of 
I> your website using the DNS system. You modify your `hosts` file only when DNS system knows nothing
I> about the domain name and can't resolve the IP address of your website.

## Advanced Composer Usage
## Composer 进阶用法

Earlier in this chapter, we have used Composer to install Zend Framework 3 library code. 
Now let's briefly describe some advanced Composer usage examples.
在本章的前面, 我们用了 Composer 来安装 Zend Framework 3 库代码.
现在让我们简短地描述下一些进阶 Composer 用法例子.

As we already know, the only required key in the `composer.json` file is `require`. This key
tells what packages are required by your application:
我们都知道, 在 `composer.json` 中仅有的需求键是 `require`. 这个键告知你的应用需要什么包.

{line-numbers=off,lang=text}
~~~
{
    "require": {
        "php": "^5.6 || ^7.0",
        "zendframework/zend-component-installer": "^1.0 || ^0.3 || ^1.0.0-dev@dev",
        "zendframework/zend-mvc": "^3.0.1",
        "zfcampus/zf-development-mode": "^3.0",
        "zendframework/zend-mvc-form": "^1.0",
        "zendframework/zend-mvc-plugins": "^1.0.1",
        "zendframework/zend-session": "^2.7.1"
    }
}
~~~

### Package Names and Versions

A package name consists of two parts: vendor name and project name. For example
"zendframework/zend-mvc" package name consists of "zendframework" vendor name
and "zend-mvc" project name. You can search for other packages from "zendframework"
vendor through [Packagist.org](https://packagist.org/search/?q=zendframework) website (see
the figure 2.8 for an example).

![Figure 2.8. You can search packages on Packagist.org](images/skeleton/packagist_search.png)

A package also has an associated version number. A version number consists of major number, minor number,
optional build number, and optional stability suffix (e.g. b1, rc1). Within the `require` key we specify which
versions of the package are acceptable. For example, "^5.6" means that we can install
versions greater than "5.6", but lower than "6.0" (that we can install only those packages that do not break
backward compatibility). In table 2.2, possible ways of specifying acceptable versions are presented:

{title="Table 2.2. Package Version Definitions"}
|-------------------------|----------------------------------------------------------------------------|
| *Definition Example*    | *Description*                                                              |
|-------------------------|----------------------------------------------------------------------------|
| 3.0.1                   | Exact version. In this example, only the version 3.0.1 can be installed.   | 
|-------------------------|----------------------------------------------------------------------------|
| >=3.0.1                 | Greater or equal version can be installed (3.0.1, 3.2.1, etc.)             |
|-------------------------|----------------------------------------------------------------------------| 
| >3.0.1                  | Greater version can be installed (3.0.2 etc.)                              |
|-------------------------|----------------------------------------------------------------------------| 
| <=3.0.1                 | Lower or equal version can be installed (1.0, 1.5, 2.0.0 etc.)             |
|-------------------------|----------------------------------------------------------------------------| 
| <3.0.1                  | Lower version can be installed (1.0, 1.1, 1.9, etc.)                       |
|-------------------------|----------------------------------------------------------------------------| 
| !=3.0.1                 | All versions except this version can be installed.                         | 
|-------------------------|----------------------------------------------------------------------------|
| >=3.0,<3.1.0            | Any version belonging to this range of versions can be installed.          |
|-------------------------|----------------------------------------------------------------------------|
| 3.*                     | Any version having major number equal to 3 can be installed (minor number  |
|                         | can be any).                                                               |
|-------------------------|----------------------------------------------------------------------------|
| ~3.0                    | Any version starting from 3.0, but lower than the next major version       |
|                         | (equivalent to >=3.0,<4.0).                                                | 
|-------------------------|----------------------------------------------------------------------------|
| ^3.0                    | Any version starting from 3.0, but lower than the next major version       |
|                         | (equivalent to >=3.0,<4.0). Similar to `~3.0`, but it sticks closer to     |
|                         | semantic versioning, and will always allow non-breaking updates.           | 
|-------------------------|----------------------------------------------------------------------------|

### Installing and Updating Packages

We've seen how to use the `php composer.phar install` command to install our dependencies. As soon as you call this
command, Composer will find, download and install the dependencies to your `vendor` subdirectory.

Q> **Is it safe to install dependencies with Composer?**
Q>
Q> Well, some people may be afraid of Composer-style dependency management, 
Q> because they think someone can update the dependencies system-wide by mistake or intentionally, 
Q> causing the web application to 
Q> break. Note, that Composer *never* installs these
Q> system-wide, instead it installs them into your `APP_DIR/vendor/` directory.

After installation, Composer also creates the `APP_DIR/composer.lock` file. This file now contains
actual versions of the packages that were installed. If you run the `install` command again,
Composer will encounter the `composer.lock` file, check which dependencies already installed and
as all packages already installed, it just exits without doing anything.
安装以后, Composer 也会创建 `APP_DIR/composer.lock` 文件. 这个文件现在包含已经安装的包的实际版本.
如果你再次运行 `install` 命令. Composer 会遇到 `composer.lock` 文件, 检查哪些依赖已经安装, 因为所有包都已经安装,
它只是推出不做任何事情.

Now assume that in some period of time new security updates for your dependency packages are released. 
You will want to update your packages to keep your website secure. You can do that by typing the following:
现在假定一段时间后你的依赖包新的安全更新发布了. 你会想要去更新你的包来保持网站安全. 你能通过键入以下完成:

`php composer.phar update`

If you want to update only a single dependency, type its name as the following:
如果你想仅仅更新一个简单的依赖, 键入它的名字通过以下方式:

`php composer.phar update zendframework/zend-mvc`

After the `update` command, your `composer.lock` file will be updated, too.
当 `update` 命令以后, 你的 `composer.lock` 文件也会更新.

Q> **What do I do if I want to roll back to a previous version of the package?**
Q>
Q> If the update procedure resulted in unwanted problems with your system, you can roll back
Q> by reverting the changes to your `composer.lock` file and issuing the `install` command again.
Q> Reverting changes to `composer.lock` is easy if you use a version control system, like GIT or SVN.
Q> If you don't use a version control system, make a backup copy of `composer.lock` before updating.

Q> **如果我想回滚到前一个包的版本, 我该怎么做?**
Q>
Q> 如果项目更新结果在一个不期望的问题, 你可以回滚通过再次恢复你的 `composer.lock` 文件, 以及 `install` 命令
Q> 如果你使用一个版本控制系统, 像 GIT 或者 SVN, 恢复 `composer.lock` 的改变是简单的
Q> 如果你不使用版本控制系统, 做一个 `composer.lock` 备份在更新前
Q>

### Adding a New Dependency
### 添加一个新的依赖

If you want to add new dependency to the application, you can either edit `composer.json`
manually, or issue `require` command. For example, to install Doctrine ORM module to your web
site (to add the "doctrine/doctrine-module" package to the 
application dependencies), type the following:

如果你想要给这个应用添加一个新的依赖, 你能手动地编辑 `composer.json` 文件, 或者发行 `require` 命令.
举个例子, 为了安装 Doctrine ORM 模块到你的站点 (为了添加 "doctrine/doctrine-module") 包到应用依赖,
键入以下:

`php composer.phar require doctrine/doctrine-module 2.*`

The command above edits `composer.json` file, and downloads and installs the package. We will use this command
later in chapter [Managing Database with Doctrine](#doctrine), when becoming familiar with database management.


### Virtual Packages
### 虚拟包

Composer can be used to require some functionality to present on your system. You've already seen
how we require "php:^5.6". PHP package is a virtual package representing PHP itself. You can also 
require other stuff, like PHP extensions (see table 2.3 below).


{title="Table 2.3. Virtual Composer Packages"}
|------------------------------------------------------------------------------------------------------|
| *Definition Example*    | *Description*                                                              |
|------------------------------------------------------------------------------------------------------|
| "php":"^5.6"            | Require PHP version greater or equal than 5.6, but lower than 6.0.         | 
|------------------------------------------------------------------------------------------------------|
| ext-dom, ext-pdo-mysql  | Require PHP DOM and PDO MySQL extensions                                   | 
|------------------------------------------------------------------------------------------------------|
| lib-openssl             | Require OpenSSL library                                                    | 
|------------------------------------------------------------------------------------------------------|

You can use `php composer.phar show --platform` command to display a list of available virtual packages
for your machine.

### Composer and Version Control Systems

If you are using a version control system (like Git), you will be curious
about what should be stored in Git: your application code only, or your application code
plus all the Composer-installed dependencies in `APP_DIR/vendor` directory?

如果你正在使用版本控制系统 (像 Git), 你会好奇什么应该存入 Git: 仅仅是你的应用代码, 或者你的应用代码
加上所有的 Composer 在 `APP_DIR/vendor`目录下已经安装的依赖?

In general, it is not recommended to store your Composer-dependencies 
under version control, because this can make your repository really big and slow to check out and branch. Instead,
you should store your `composer.lock` file under version control. The `composer.lock`
file guarantees that everyone will install the same versions of dependencies as you have.
This is useful in development teams having more than one developer, because all
developers should have the same code to avoid unwanted issues with environment
misconfiguration.

通常, 不推荐存储你的 Composer 依赖项到你的版本控制下, 因为这会将你的仓库变得非常大, 以及 check out 和 branch 会变得非常慢.
取而代之的, 你应该存储你的 `composer.lock` 文件在版本控制下.  `composer.lock` 文件担保每一个人安装跟你相同的版本依赖.
这在超过一个开发者的团队里面是非常有用的, 因为所有开发者应该有相同的代码去避免因为环境错误配置导致的不期望的问题.

Q> **What if some dependence will be declared obsolete and removed from Packagist.org?**
Q>
Q> Well, the possibility of package removal is minimum. All packages are free and open-source,
Q> and the community of users can always restore the dependency even if it is removed from packagist.
Q> By the way, the same concept of dependency installation is used in Linux (remember APT or RPM manager?),
Q> so did anyone see any Linux package lost?

Q> **假使一些依赖会被声明废弃, 以及从 Packagist.org 移除呢?**
Q>
Q> 好了, 包被移除的可能性是非常小的, 所有包是免费和开源的
Q> 用户社区可以始终存储依赖, 即便是从 packagist 中被移除掉.
Q> 顺带一提, 这相同的依赖安装器观点被运用到了 Linux 中 (想想 APT 或者 RPM 管理器?),
Q> 所以有人看到 Linux 包丢失掉了?

But there may be situations when you *should* store some dependent libraries under
version control:

以下是一些情况当你 *需要* 在版本控制下保存依赖库:

* If you have to make custom changes to third-party code. For example, assume
  you have to fix a bug in a library, and you cannot wait for the library's vendor
  to fix it for you (or if the library vendor cannot fix the bug). In this case,
  you should place the library code under version control to ensure your custom
  changes won't be lost.

* 如果你对第三方做出了特定的修改. 举个例子, 假定你在库中修复了一个 bug, 然后你等不到库原来的
  的主人为你修复 (或者库主人不能修复这个 bug). 在这种情况下, 你应该在版本控制下放置库代码, 确保你自定的改变不会丢失.

* If you have written a reusable module or library and want to store it in the `vendor`
  directory without publishing it on *Packagist.org*. Because you don't have an ability
  to install this code from the Packagist, you should store it under version control.
* 如果你写了一个可用的模块或者库, 在没有将它发布到 *Packagist.org* 的情况下想存储到 `vendor` 目录下.
  因为你没有能力从 Packagist 中安装代码, 所以你应该在版本控制中保存它.

* If you want a 100% guarantee that a third-party package won't be lost. Although
  the risk is minimum, for some applications it is critical to be autonomous and
  not depend on package availability on *Packagist.org*.
  如果你想要担保 100% 第三方包不被丢失, 虽然风险是非常小的, 但对于部分应用来说是至关重要的不依赖
  *Packagist.org*.

## Summary

In this chapter, we have downloaded the Zend Skeleton Application project 
code from GitHub and installed it via Composer dependency manager. 
We've configured the Apache Virtual Host to tell the web server about location
of the website's document root directory.

The skeleton application demonstrates the recommended directory structure of a typical website. 
We have the `public` directory containing files publicly accessible by site users, including the `index.php` 
entry point file, CSS files, JavaScript files and images. All other directories of the
application are inaccessible by site users and contain application configuration, data and
modules.

In the second part of the chapter we discussed some advanced Apache configuration. For example, you 
can protect your website with password and
allow accessing it from certain IP addresses only.

The Composer dependency manager is a powerful tool for installing the dependencies of 
your website. For example, Zend Framework 3 itself can be considered as a dependency. 
All packages installable by Composer are registered in a centralized catalog on the 
Packagist.org site.

